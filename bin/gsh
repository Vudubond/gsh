#!/usr/bin/env python

import argparse
import logging
import os
import sys

import gsh as _gsh
from gsh import Gsh
from gsh.plugin import get_loaders, get_hooks


logging.basicConfig()

def _create_action(plugin):
    class _LoaderAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            if not getattr(namespace, self.dest, None):
                setattr(namespace, self.dest, {})
            loaders = getattr(namespace, self.dest)
            loaders.setdefault(plugin, []).append(values)
    return _LoaderAction


def _setup_plugin_options(parser, plugins):
    for plugin in plugins:
        args = []

        if plugin.opt_short:
            args.append(plugin.opt_short)
        if plugin.opt_long:
            args.append(plugin.opt_long)

        if args and plugin.opt_help and isinstance(plugin.opt_help, basestring):
            parser.add_argument(
                *args, default={}, dest="loaders", metavar=plugin.opt_metavar,
                action=_create_action(plugin), help=plugin.opt_help)


def _parse_args():

    description_msg = "Run a command across many machines."
    parser = argparse.ArgumentParser(description=description_msg, add_help=False)

    # Do a first pass of parsing where we ignore unknown options so that we can
    # make use of options which will discover plugins and potentially load more
    # options.
    parser.add_argument("-p", "--plugin_dir", default=[], help="Directories containing additional plugins.")
    args, unknown = parser.parse_known_args()

    # Delay parsing of most options until the second pass due to a bug in argparse that
    # treats -abc differently from -a -b -c when parsing unknown args.
    parser.add_argument("command", nargs=argparse.REMAINDER, default=None, help="Command to execute remotely.")
    parser.add_argument("-t", "--timeout", default=0, type=int, help="How long to allow a command to run before timeout.")
    parser.add_argument("-F", "--forklimit", default=64, type=int, help="Limit on concurrenct processes.")

    parser.add_argument("-M", "--show-machine-names", dest="print_machines",
                        action="store_true", default=True, help="Prepend the hostname to output.")
    parser.add_argument("-H", "--hide-machine-names", dest="print_machines",
                        action="store_false", default=True, help="Do not prepend hostname to output.")

    parser.add_argument("-c", "--concurrent-shell", dest="concurrent",
                        action="store_true", default=True, help="Execute commands concurrently.")
    parser.add_argument("-w", "--wait-shell", dest="concurrent",
                        action="store_false", default=True, help="Force sequentially execution.")
    parser.add_argument("-V", "--version", action="store_true", default=False, help="Display version information.")

    # We specify add_help=False and explicitly define it here so it gets picked up in the second
    # pass of parsing and displays the loader plugin help.
    parser.add_argument("-h", "--help", action='help', default=argparse.SUPPRESS,
                        help="show this help message and exit")

    loader_group = parser.add_argument_group("loaders", "Host Loaders")
    _setup_plugin_options(loader_group, get_loaders())

    return parser, parser.parse_args()

def main():

    parser, args = _parse_args()

    if args.version:
        print "Gary's Shell / Version: %s" % _gsh.__version__
        sys.exit()

    if not args.loaders:
        parser.print_help()
        sys.exit()

    hosts = set()
    for plugin, options in args.loaders.iteritems():
        hosts.update(plugin(*options))

    if not args.command or not any(args.command):
        if hosts:
            print "\n".join(hosts)
        sys.exit()

    hooks = get_hooks()
    printer = hooks.PrinterHook
    if args.print_machines:
        printer = hooks.MachinePrinterHook

    forklimit = args.forklimit
    if not args.concurrent:
        forklimit = 1

    try:
        gsh = Gsh(hosts, args.command, fork_limit=forklimit,
                  timeout=args.timeout, hooks=[printer])
        gsh.run_async()
        sys.exit(gsh.wait())
    except KeyboardInterrupt:
        sys.exit("Bye")


if __name__ == "__main__":
    main()
